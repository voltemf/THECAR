<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VROOM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #mainMenu, #garage, #trackSelect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #ff6600;
            text-align: center;
            z-index: 100;
            min-width: 400px;
        }
        h1 {
            color: #ff6600;
            margin-bottom: 20px;
            font-size: 48px;
            text-shadow: 0 0 20px #ff6600;
        }
        h2 {
            color: #ff6600;
            margin-bottom: 20px;
            font-size: 32px;
        }
        button {
            background: linear-gradient(135deg, #ff6600, #ff9933);
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #ff6600;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: scale(1);
            box-shadow: none;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            text-shadow: 2px 2px 4px #000;
            z-index: 50;
        }
        #driftInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
            z-index: 50;
        }
        .drift-active {
            color: #ff6600;
            font-size: 32px;
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        #combo {
            color: #ffcc00;
            font-size: 48px;
            font-weight: bold;
        }
        .car-option, .track-option {
            background: rgba(40, 40, 50, 0.8);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.3s;
        }
        .car-option:hover, .track-option:hover {
            border-color: #ff6600;
            transform: translateX(5px);
        }
        .car-option.selected, .track-option.selected {
            border-color: #ff6600;
            background: rgba(255, 102, 0, 0.2);
        }
        .upgrade-section {
            margin: 20px 0;
            text-align: left;
        }
        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(40, 40, 50, 0.6);
            margin: 5px 0;
            border-radius: 5px;
        }
        .upgrade-bar {
            width: 200px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin: 0 10px;
            overflow: hidden;
        }
        .upgrade-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffcc00);
            transition: width 0.3s;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 16px;
            text-shadow: 2px 2px 4px #000;
            z-index: 50;
        }
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff6600;
            border-radius: 10px;
            z-index: 50;
        }
        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff6600;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Arial', sans-serif;
            color: #fff;
            text-align: center;
            z-index: 100;
            min-width: 120px;
        }
        #speedometer .speed-value {
            font-size: 32px;
            font-weight: bold;
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
        }
        #speedometer .speed-unit {
            font-size: 14px;
            color: #ccc;
        }
        #gearDisplay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff6600;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Arial', sans-serif;
            color: #fff;
            text-align: center;
            z-index: 100;
            min-width: 80px;
        }
        #gearDisplay .gear-value {
            font-size: 28px;
            font-weight: bold;
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
        }
        #gearDisplay .gear-label {
            font-size: 12px;
            color: #ccc;
        }
        #nitroDisplay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 10px 20px;
            font-family: 'Arial', sans-serif;
            color: #fff;
            text-align: center;
            z-index: 100;
            min-width: 200px;
        }
        #nitroDisplay .nitro-bar {
            width: 100px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin: 5px 0;
            overflow: hidden;
        }
        #nitroDisplay .nitro-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00);
            transition: width 0.1s;
        }
        .nitro-active {
            animation: nitroFlash 0.5s infinite;
        }
        @keyframes nitroFlash {
            0%, 100% { border-color: #00ff00; }
            50% { border-color: #ffff00; }
        }
        
        #carDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff6600;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Arial', sans-serif;
            color: #fff;
            text-align: center;
            z-index: 100;
            min-width: 150px;
        }
        #carDisplay .car-name {
            font-size: 16px;
            font-weight: bold;
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
        }
        #carDisplay .car-instruction {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }
        
        #carGuide {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff6600;
            font-size: 12px;
            color: #fff;
            max-width: 200px;
        }
        #carGuide h4 {
            color: #ff6600;
            margin: 0 0 10px 0;
            text-align: center;
        }
        #carGuide .car-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #carGuide .car-list li {
            margin: 3px 0;
            padding: 2px 0;
        }
        #carGuide .car-key {
            color: #ff6600;
            font-weight: bold;
            margin-right: 8px;
        }
        
        /* Mobile Controls */
        #mobileControls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 200;
        }
        
        .mobile-joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #ff6600;
            border-radius: 50%;
            touch-action: none;
        }
        
        .mobile-joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: #ff6600;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }
        
        .mobile-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .mobile-button {
            width: 80px;
            height: 60px;
            background: rgba(255, 102, 0, 0.8);
            border: 2px solid #ff6600;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        .mobile-button:active {
            background: rgba(255, 102, 0, 1);
            transform: scale(0.95);
        }
        
        /* Developer Menu */
        #developerMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 3px solid #00ff00;
            border-radius: 15px;
            padding: 20px;
            color: #fff;
            font-family: 'Arial', sans-serif;
            min-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        #developerMenu h2 {
            color: #00ff00;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .dev-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(20, 20, 30, 0.8);
            border-radius: 10px;
            border: 1px solid #333;
        }
        
        .dev-section h3 {
            color: #00ff00;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .car-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .setting-group {
            margin-bottom: 10px;
        }
        
        .setting-group label {
            display: block;
            color: #ccc;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .setting-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .setting-group input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #555;
            background: #222;
            color: #fff;
            border-radius: 5px;
        }
        
        .setting-group input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 2px dashed #555;
            background: #222;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .setting-group input[type="file"]:hover {
            border-color: #00ff00;
            background: #333;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #00ff00;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .dev-button {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .dev-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #00ff00;
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            #speedometer {
                bottom: 220px;
            }
            
            #nitroDisplay {
                top: 20px;
                right: 20px;
            }
        }
    </style>
    </head>
<body>
    <div id="speedometer">
        <div class="speed-value" id="speedValue">0</div>
        <div class="speed-unit">km/h</div>
    </div>
    
    <div id="nitroDisplay">
        <div class="nitro-bar">
            <div class="nitro-fill" id="nitroFill" style="width: 100%;"></div>
        </div>
    </div>
    
    <div id="carDisplay">
        <div class="car-name" id="carName">MB Car</div>
        <div class="car-instruction">Press T to cycle | 1-6 for specific car</div>
        <div style="color: #00ff00; font-size: 12px; margin-top: 5px;">
            🚀 Press SHIFT for NITRO | Click screen to focus
        </div>
    </div>
    
    <div id="carGuide">
        <h4>Car Selection</h4>
        <ul class="car-list">
            <li><span class="car-key">1</span>MB Car</li>
            <li><span class="car-key">2</span>GT3 Porsche</li>
            <li><span class="car-key">3</span>Batmobile Tumbler</li>
            <li><span class="car-key">4</span>Batmobile 1989</li>
            <li><span class="car-key">5</span>Lamborghini Diablo</li>
            <li><span class="car-key">6</span>Dodge Hellcat</li>
        </ul>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div class="mobile-joystick" id="joystick">
            <div class="mobile-joystick-handle" id="joystickHandle"></div>
        </div>
        <div class="mobile-buttons">
            <div class="mobile-button" id="nitroBtn">NITRO</div>
            <div class="mobile-button" id="brakeBtn">BRAKE</div>
            <div class="mobile-button" id="switchCarBtn">SWITCH</div>
        </div>
    </div>
    
    <!-- Developer Menu -->
    <div id="developerMenu">
        <h2>🛠️ DEVELOPER MENU 🛠️</h2>
        <div class="dev-section">
            <h3>🚗 Vehicle Settings</h3>
            <div class="car-settings" id="carSettings">
                <!-- Vehicle controls will be populated here -->
            </div>
        </div>
        
        <div class="dev-section">
            <h3>📹 Camera Controls</h3>
            <div class="setting-group">
                <label>Camera Mode:</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="cameraToggle">
                    <span class="slider"></span>
                </label>
                <span id="cameraMode">Follow Car</span>
                <small style="display: block; color: #888; margin-top: 5px;">
                    Free Camera: WASD to fly, Q/E up/down, Mouse to look around
                </small>
            </div>
            <div class="setting-group">
                <label>Camera Distance:</label>
                <input type="range" id="cameraDistance" min="100" max="1000" value="300">
                <input type="number" id="cameraDistanceValue" value="300">
            </div>
            <div class="setting-group">
                <label>Camera Height:</label>
                <input type="range" id="cameraHeight" min="50" max="500" value="150">
                <input type="number" id="cameraHeightValue" value="150">
            </div>
        </div>
        
        <div class="dev-section">
            <h3>🌍 World Settings</h3>
            <div class="setting-group">
                <label>Jump Power:</label>
                <input type="range" id="jumpPower" min="5" max="30" value="10">
                <input type="number" id="jumpPowerValue" value="10">
            </div>
            <div class="setting-group">
                <label>Gravity:</label>
                <input type="range" id="gravity" min="0.1" max="2" step="0.1" value="0.8">
                <input type="number" id="gravityValue" value="0.8" step="0.1">
            </div>
        </div>
        
        <div class="dev-section">
            <h3>🗺️ Map Management</h3>
            <div class="setting-group">
                <label>Import Custom Map (.gltf/.glb):</label>
                <input type="file" id="mapUpload" accept=".gltf,.glb" style="margin-bottom: 10px;">
                <small style="display: block; color: #888; margin-bottom: 10px;">
                    Upload your own 3D map in GLTF or GLB format
                </small>
                <button class="dev-button" onclick="loadDefaultMap()">🏠 Load Default Map</button>
                <button class="dev-button" onclick="clearMap()">🗑️ Clear Map</button>
            </div>
            <div class="setting-group">
                <label>Map Scale:</label>
                <input type="range" id="mapScale" min="1" max="1000" value="500">
                <input type="number" id="mapScaleValue" value="500">
                <small style="display: block; color: #888;">
                    Adjust the size of imported maps
                </small>
            </div>
        </div>
        
        <div class="dev-section">
            <h3>🎨 Texture Management</h3>
            <div class="setting-group">
                <label>Upload Car Texture (.jpg/.png):</label>
                <input type="file" id="carTextureUpload" accept=".jpg,.jpeg,.png" style="margin-bottom: 10px;">
                <small style="display: block; color: #888; margin-bottom: 10px;">
                    Upload custom textures for vehicles
                </small>
                <button class="dev-button" onclick="applyCachedTexture()">🎨 Apply Texture to Current Car</button>
                <button class="dev-button" onclick="resetCarTexture()">🔄 Reset Car Texture</button>
            </div>
            <div class="setting-group">
                <label>Upload Environment Texture (.jpg/.png):</label>
                <input type="file" id="envTextureUpload" accept=".jpg,.jpeg,.png" style="margin-bottom: 10px;">
                <small style="display: block; color: #888; margin-bottom: 10px;">
                    Upload textures for map/environment elements
                </small>
                <button class="dev-button" onclick="applyCachedEnvTexture()">🌍 Apply Environment Texture</button>
                <button class="dev-button" onclick="resetEnvTexture()">🔄 Reset Environment Texture</button>
            </div>
        </div>
        
        <div class="dev-section">
            <button class="dev-button" onclick="resetToDefaults()">🔄 Reset All Settings</button>
            <button class="dev-button" onclick="saveSettings()">💾 Save Settings</button>
            <button class="dev-button" onclick="loadSettings()">📁 Load Settings</button>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer, playerCar;
        let keys = {};
        let carVelocity = new THREE.Vector3();
        let carRotation = 0;
        let currentSpeed = 0;
        let trackObjects = [];
        let gltfLoader = null;
        
        // Camera constraints
        const MAX_CAMERA_DISTANCE = 20;
        const MIN_CAMERA_DISTANCE = 12;
        const CAMERA_HEIGHT = 10;
        
        // Mouse controls
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let cameraOffsetX = 0;
        let cameraOffsetY = 0;
        let targetOffsetX = 0;
        let targetOffsetY = 0;
        
        // Nitro system
        let nitroActive = false;
        let nitroTimeLeft = 0;
        let nitroFading = false; // New variable for smooth transition
        let nitroFadeProgress = 0; // Progress of nitro fade (0 = full nitro, 1 = no nitro)
        const NITRO_DURATION = 10; // 10 seconds
        const NITRO_MULTIPLIER = 1.8; // Reduced from 2.5 to 1.8 for smoother acceleration
        const NITRO_FADE_DURATION = 3.0; // 3 seconds to fade out nitro effects
        
        // Mobile controls
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickInput = { x: 0, y: 0 };
        let mobileNitro = false;
        let mobileBrake = false;
        
        // Car switching system
        let currentCarIndex = 0;
        const availableCars = [
            { name: 'MB Car', path: 'MB/scene.gltf', topSpeed: 1.0, acceleration: 0.045 }, // ~300 km/h
            { name: 'GT3 Porsche', path: 'gt3/porsche_911992_gt3_rs_mr/scene.gltf', topSpeed: 1.2, acceleration: 0.055 }, // ~360 km/h
            { name: 'Batmobile Tumbler', path: 'bat1/batmobiletumbler/scene.gltf', topSpeed: 1.4, acceleration: 0.065 }, // ~420 km/h
            { name: 'Batmobile 1989', path: 'bat2/batmobile_1989/scene.gltf', topSpeed: 1.1, acceleration: 0.050 }, // ~330 km/h
            { name: 'Lamborghini Diablo', path: 'diablo/1995_lamborghini_diablo_sv/scene.gltf', topSpeed: 1.3, acceleration: 0.060 }, // ~390 km/h
            { name: 'Dodge Hellcat', path: 'hcat/dodge_charger_srt_hellcat__high_quality/scene.gltf', topSpeed: 1.15, acceleration: 0.065 } // ~345 km/h
        ];

        // Jump system for Batmobile Tumbler
        let isJumping = false;
        let jumpVelocity = 0;
        let groundLevel = 0;
        const JUMP_POWER = 10;
        const GRAVITY = 0.8;

        // Map management
        let currentMap = null;
        let mapScale = 50; // Reduced from 500 to make map more reasonable size
        let isCustomMap = false;

        // Texture management
        let cachedCarTexture = null;
        let cachedEnvTexture = null;
        let originalCarMaterials = new Map(); // Store original materials for reset
        let textureLoader = new THREE.TextureLoader();
        function createSkybox() {
            console.log('🌅 Creating sunset skybox...');
            
            // Create sunset skybox with clouds
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const context = canvas.getContext('2d');
            
            if (!context) {
                console.error('❌ Failed to get 2D context for skybox canvas');
                return;
            }
            
            console.log('✅ Canvas created:', canvas.width, 'x', canvas.height);
            
            // Create sunset gradient background
            console.log('🎨 Creating gradient...');
            const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');     // Deep purple at top
            gradient.addColorStop(0.2, '#16213e');   // Dark blue
            gradient.addColorStop(0.4, '#0f3460');   // Navy blue
            gradient.addColorStop(0.6, '#e94560');   // Pink/red
            gradient.addColorStop(0.8, '#f39c12');   // Orange
            gradient.addColorStop(1, '#f1c40f');     // Golden yellow at horizon
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            console.log('✅ Gradient applied to canvas');
            
            // Add procedural clouds
            function drawClouds() {
                console.log('☁️ Drawing clouds...');
                context.globalCompositeOperation = 'overlay';
                
                // Generate multiple cloud layers
                for (let layer = 0; layer < 3; layer++) {
                    const numClouds = 15 + layer * 5;
                    const opacity = 0.3 - layer * 0.1;
                    const size = 80 + layer * 40;
                    
                    for (let i = 0; i < numClouds; i++) {
                        const x = Math.random() * canvas.width;
                        const y = canvas.height * 0.3 + Math.random() * canvas.height * 0.4;
                        
                        // Create cloud gradient
                        const cloudGradient = context.createRadialGradient(x, y, 0, x, y, size);
                        cloudGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                        cloudGradient.addColorStop(0.5, `rgba(255, 200, 150, ${opacity * 0.8})`);
                        cloudGradient.addColorStop(1, `rgba(255, 150, 100, 0)`);
                        
                        context.fillStyle = cloudGradient;
                        context.beginPath();
                        context.arc(x, y, size, 0, Math.PI * 2);
                        context.fill();
                        
                        // Add smaller cloud puffs
                        for (let j = 0; j < 3; j++) {
                            const offsetX = x + (Math.random() - 0.5) * size;
                            const offsetY = y + (Math.random() - 0.5) * size * 0.5;
                            const puffSize = size * (0.3 + Math.random() * 0.4);
                            
                            const puffGradient = context.createRadialGradient(offsetX, offsetY, 0, offsetX, offsetY, puffSize);
                            puffGradient.addColorStop(0, `rgba(255, 220, 180, ${opacity * 0.6})`);
                            puffGradient.addColorStop(1, 'rgba(255, 180, 120, 0)');
                            
                            context.fillStyle = puffGradient;
                            context.beginPath();
                            context.arc(offsetX, offsetY, puffSize, 0, Math.PI * 2);
                            context.fill();
                        }
                    }
                }
                
                context.globalCompositeOperation = 'source-over';
                console.log('✅ Clouds drawn successfully');
            }
            
            console.log('🎯 About to draw clouds...');
            drawClouds();
            
            // Create texture and set as scene background
            const texture = new THREE.CanvasTexture(canvas);
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.needsUpdate = true;
            
            console.log('🖼️ Texture created, applying to scene...');
            
            // Set as scene background (this is more reliable than sphere method)
            scene.background = texture;
            console.log('🌅 Sunset skybox with clouds applied to scene background');
            
            // Verify the scene background was set
            if (scene.background === texture) {
                console.log('✅ Scene background successfully set to sunset texture');
            } else {
                console.error('❌ Failed to set scene background');
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xff9966, 200, 1200); // Warm orange fog for sunset
            
            // Create skybox
            createSkybox();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 20, 50); // Higher and further back to see everything
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.body.appendChild(renderer.domElement);
            
            // Ensure the canvas can receive focus for keyboard events
            renderer.domElement.tabIndex = 0;
            renderer.domElement.focus();
            renderer.domElement.style.outline = 'none'; // Remove focus outline
            
            // Add click to focus functionality
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.focus();
                console.log('🎯 Canvas focused - keyboard input should work now');
            });
            
            // Add a focus indicator for debugging
            renderer.domElement.addEventListener('focus', () => {
                console.log('🎯 Canvas has focus - keys should work');
                renderer.domElement.style.border = '2px solid green';
                setTimeout(() => {
                    renderer.domElement.style.border = 'none';
                }, 1000);
            });
            
            renderer.domElement.addEventListener('blur', () => {
                console.log('⚠️ Canvas lost focus - click to regain focus');
            });
            
            // Initialize GLB loader
            gltfLoader = new THREE.GLTFLoader();
            
            // Initialize texture loader
            textureLoader = new THREE.TextureLoader();
            // Sunset lighting setup
            const ambientLight = new THREE.AmbientLight(0xffa366, 0.4); // Warm orange ambient
            scene.add(ambientLight);
            
            // Main sunset directional light (low angle like setting sun)
            const dirLight = new THREE.DirectionalLight(0xff6b35, 1.2); // Orange sunset light
            dirLight.position.set(-100, 30, 100); // Low angle from horizon
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            // Additional sunset atmosphere lighting
            const rimLight = new THREE.DirectionalLight(0xffaa44, 0.8); // Golden rim light
            rimLight.position.set(200, 80, -150); // From opposite side
            scene.add(rimLight);
            
            // Soft purple light from the opposite direction for contrast
            const fillLight = new THREE.DirectionalLight(0x9966ff, 0.3); // Purple fill light
            fillLight.position.set(-50, 100, -100);
            scene.add(fillLight);
            
            createTrack('parkrug');
            createPlayerCar();
            
            // Add a debug marker at origin to help see scale
            const debugGeometry = new THREE.BoxGeometry(2, 2, 2);
            const debugMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const debugCube = new THREE.Mesh(debugGeometry, debugMaterial);
            debugCube.position.set(0, 1, 0);
            scene.add(debugCube);
            console.log('🎯 Debug red cube added at origin (0,1,0)');
            
            // Initialize car display
            setTimeout(() => {
                updateCarDisplay();
            }, 200);
            
            window.addEventListener('resize', onWindowResize);
            
            // Add event listeners to the canvas specifically for better focus
            renderer.domElement.addEventListener('keydown', onKeyDown);
            renderer.domElement.addEventListener('keyup', onKeyUp);
            
            // Also add to document as backup
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse controls
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', (e) => e.preventDefault()); // Disable right-click menu
            
            // Mobile controls
            initMobileControls();
            
            animate();
        }
        
        // Function to load GLB models
        function loadGLBModel(url, position = { x: 0, y: 0, z: 0 }, scale = 1) {
            return new Promise((resolve, reject) => {
                gltfLoader.load(
                    url,
                    (gltf) => {
                        const model = gltf.scene;
                        model.position.set(position.x, position.y, position.z);
                        model.scale.set(scale, scale, scale);
                        
                        // Enable shadows for all meshes in the model
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        scene.add(model);
                        console.log('GLB model loaded successfully:', url);
                        resolve(model);
                    },
                    (progress) => {
                        const percent = (progress.loaded / progress.total * 100).toFixed(2);
                        console.log(`Loading GLB: ${percent}%`);
                    },
                    (error) => {
                        console.error('Error loading GLB model:', error);
                        reject(error);
                    }
                );
            });
        }
        
        // Example: Load a car model from GLB file
        // Uncomment and provide your GLB file path to use
        // loadGLBModel('path/to/your/car.glb', { x: 10, y: 0, z: 10 }, 2);

        function createPlayerCar() {
            if (playerCar) scene.remove(playerCar);
            
            const carGroup = new THREE.Group();
            
            // Load the current selected car
            const currentCar = availableCars[currentCarIndex];
            if (gltfLoader) {
                console.log(`Loading car: ${currentCar.name}`);
                gltfLoader.load(
                    currentCar.path,
                    (gltf) => {
                        const model = gltf.scene;
                        
                        // Apply car-specific scaling and adjustments
                        if (currentCar.name === 'Batmobile Tumbler') {
                            model.scale.set(1.5, 1.5, 1.5); // Smaller scale for Tumbler
                        } else {
                            model.scale.set(3, 3, 3); // Default scale for other cars
                        }
                        
                        // Apply car-specific rotations
                        if (currentCar.name === 'GT3 Porsche') {
                            model.rotation.y = Math.PI; // 180 degrees
                        } else if (currentCar.name === 'Batmobile Tumbler') {
                            model.rotation.y = Math.PI * 1.5; // 270 degrees (180 + 90)
                        } else if (currentCar.name === 'Batmobile 1989') {
                            model.rotation.y = Math.PI / 2; // 90 degrees
                        } else if (currentCar.name === 'Lamborghini Diablo') {
                            model.rotation.y = Math.PI * 2; // 360 degrees (equivalent to 0)
                        } else if (currentCar.name === 'Dodge Hellcat') {
                            model.rotation.y = Math.PI * 2; // 360 degrees (equivalent to 0)
                        }
                        // Other cars (MB) use default rotation (0)
                        
                        // Center the model and lift it up so wheels touch ground
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        // Car-specific positioning adjustments
                        if (currentCar.name === 'Batmobile Tumbler') {
                            // Lower Tumbler much deeper into the ground for visibility
                            model.position.set(-center.x, -box.min.y - 10.0, -center.z);
                        } else {
                            // Standard positioning for other cars
                            model.position.set(-center.x, -box.min.y + 0.2, -center.z);
                        }
                        
                        // Configure the model
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Make the car brighter
                                if (child.material) {
                                    // If it's an array of materials
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(mat => {
                                            mat.emissive = new THREE.Color(0x111111); // Add slight glow
                                            mat.emissiveIntensity = 0.2;
                                        });
                                    } else {
                                        // Single material
                                        child.material.emissive = new THREE.Color(0x111111);
                                        child.material.emissiveIntensity = 0.2;
                                    }
                                }
                            }
                        });
                        
                        // Add model to car group
                        carGroup.add(model);
                        console.log(`${currentCar.name} loaded successfully`);
                        console.log(`Car position: x=${carGroup.position.x}, y=${carGroup.position.y}, z=${carGroup.position.z}`);
                        console.log(`Car scale: x=${model.scale.x}, y=${model.scale.y}, z=${model.scale.z}`);
                        
                        // Reset camera to look at the car
                        camera.position.set(0, 20, 50);
                        camera.lookAt(carGroup.position);
                    },
                    (progress) => {
                        if (progress.total > 0) {
                            const percent = (progress.loaded / progress.total * 100).toFixed(2);
                            console.log(`Loading car model: ${percent}%`);
                        }
                    },
                    (error) => {
                        console.error('Error loading GLTF car model:', error);
                        console.log('Using fallback basic car');
                        // Fallback to basic car if model fails to load
                        createBasicCar(carGroup);
                    }
                );
            } else {
                // Fallback to basic car if loader not ready
                createBasicCar(carGroup);
            }
            
            carGroup.position.set(0, 0, 0);
            scene.add(carGroup);
            playerCar = carGroup;
            
            // Reset camera to follow the car immediately
            camera.position.set(0, 20, 50);
            if (carGroup) {
                camera.lookAt(carGroup.position);
            }
            camera.lookAt(0, 0, 0);
            
            // Initialize displays
            updateNitroDisplay();
            updateCarDisplay();
        }
        
        function createBasicCar(carGroup) {
            const bodyGeom = new THREE.BoxGeometry(2, 1, 4);
            const bodyMat = new THREE.MeshPhongMaterial({ 
                color: 0xff6600,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);
            
            const roofGeom = new THREE.BoxGeometry(1.5, 0.8, 2);
            const roof = new THREE.Mesh(roofGeom, bodyMat);
            roof.position.set(0, 1.3, -0.3);
            roof.castShadow = true;
            carGroup.add(roof);
            
            const hoodGeom = new THREE.BoxGeometry(1.8, 0.2, 1.5);
            const hood = new THREE.Mesh(hoodGeom, bodyMat);
            hood.position.set(0, 0.95, 1.5);
            hood.castShadow = true;
            carGroup.add(hood);
            
            const wheelGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            
            const wheels = [];
            const wheelPos = [
                [-1.1, 0.4, 1.5], [1.1, 0.4, 1.5],
                [-1.1, 0.4, -1.5], [1.1, 0.4, -1.5]
            ];
            
            wheelPos.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                wheel.castShadow = true;
                carGroup.add(wheel);
                wheels.push(wheel);
            });
            
            carGroup.userData.wheels = wheels;
        }

        function createTrack(type, customMapData = null) {
            trackObjects.forEach(obj => scene.remove(obj));
            trackObjects = [];
            
            if (customMapData) {
                // Load custom uploaded map
                loadCustomMap(customMapData);
                isCustomMap = true;
            } else if (type === 'parkrug') {
                // Load the PARKRUG map instead of creating procedural track
                if (gltfLoader) {
                    gltfLoader.load(
                        'PARKRUG/traffic_rug/scene.gltf',
                        (gltf) => {
                            const mapModel = gltf.scene;
                            
                            // Scale the map up by current scale value
                            mapModel.scale.set(mapScale, mapScale, mapScale);
                            
                            // Flatten the map by removing any rotation/tilt and centering
                            mapModel.rotation.set(0, 0, 0);
                            mapModel.position.set(0, 0, 0); // Center and ensure it's at ground level
                            
                            // Force flatten all child meshes
                            mapModel.traverse((child) => {
                                if (child.isMesh) {
                                    child.rotation.set(0, 0, 0);
                                    // Reset any local transformations that might cause tilting
                                    child.position.y = Math.max(child.position.y, 0);
                                }
                            });
                            
                            // Configure the map model
                            mapModel.traverse((child) => {
                                if (child.isMesh) {
                                    child.receiveShadow = true;
                                    child.castShadow = true;
                                }
                            });
                            
                            // Add map to scene
                            scene.add(mapModel);
                            trackObjects.push(mapModel);
                            currentMap = mapModel;
                            isCustomMap = false;
                            
                            console.log(`PARKRUG map loaded successfully (scaled ${mapScale}x, flattened)`);
                            console.log(`Map position: x=${mapModel.position.x}, y=${mapModel.position.y}, z=${mapModel.position.z}`);
                            console.log(`Map scale: x=${mapModel.scale.x}, y=${mapModel.scale.y}, z=${mapModel.scale.z}`);
                        },
                        (progress) => {
                            if (progress.total > 0) {
                                const percent = (progress.loaded / progress.total * 100).toFixed(2);
                                console.log(`Loading map: ${percent}%`);
                            }
                        },
                        (error) => {
                            console.error('Error loading PARKRUG map:', error);
                            console.log('Creating fallback ground plane');
                            createFallbackGround();
                        }
                    );
                } else {
                    createFallbackGround();
                }
            } else {
                createFallbackGround();
            }
        }
        
        function createFallbackGround() {
            // Fallback ground plane if GLTF fails to load
            const groundGeom = new THREE.PlaneGeometry(500, 500);
            const groundMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            trackObjects.push(ground);
            currentMap = ground;
            isCustomMap = false;
        }
        
        function loadCustomMap(mapData) {
            console.log('🗺️ Loading custom map...');
            
            if (gltfLoader) {
                gltfLoader.parse(
                    mapData,
                    '', // Base URL (empty for blob data)
                    (gltf) => {
                        const mapModel = gltf.scene;
                        
                        // Apply current scale
                        mapModel.scale.set(mapScale, mapScale, mapScale);
                        
                        // Center and flatten the map
                        mapModel.rotation.set(0, 0, 0);
                        mapModel.position.set(0, 0, 0);
                        
                        // Force flatten all child meshes
                        mapModel.traverse((child) => {
                            if (child.isMesh) {
                                child.rotation.set(0, 0, 0);
                                child.position.y = Math.max(child.position.y, 0);
                                child.receiveShadow = true;
                                child.castShadow = true;
                            }
                        });
                        
                        // Add map to scene
                        scene.add(mapModel);
                        trackObjects.push(mapModel);
                        currentMap = mapModel;
                        isCustomMap = true;
                        
                        console.log('✅ Custom map loaded successfully!');
                    },
                    (error) => {
                        console.error('❌ Error loading custom map:', error);
                        alert('Error loading custom map. Please check the file format and try again.');
                        createFallbackGround();
                    }
                );
            } else {
                console.error('❌ GLTF loader not available');
                createFallbackGround();
            }
        }
        
        function loadDefaultMap() {
            console.log('🏠 Loading default map...');
            createTrack('parkrug');
        }
        
        function clearMap() {
            console.log('🗑️ Clearing map...');
            trackObjects.forEach(obj => scene.remove(obj));
            trackObjects = [];
            currentMap = null;
            isCustomMap = false;
            createFallbackGround();
        }
        
        function updateMapScale() {
            if (currentMap && trackObjects.length > 0) {
                console.log(`🔄 Updating map scale to ${mapScale}x`);
                currentMap.scale.set(mapScale, mapScale, mapScale);
            }
        }



        function updateCarPhysics() {
            if (!playerCar) return; // Don't update if car isn't loaded yet
            
            // Update nitro system
            if (nitroActive && nitroTimeLeft > 0) {
                nitroTimeLeft -= 0.016; // Decrease by frame time
                if (nitroTimeLeft <= 0) {
                    nitroActive = false;
                    nitroTimeLeft = 0;
                    nitroFading = true; // Start fading
                    nitroFadeProgress = 0;
                }
            }
            
            // Handle nitro fade out
            if (nitroFading) {
                nitroFadeProgress += 0.016 / NITRO_FADE_DURATION; // Increase fade progress
                if (nitroFadeProgress >= 1.0) {
                    nitroFading = false;
                    nitroFadeProgress = 0;
                }
            }
            
            // Base engine power with nitro multiplier
            let enginePower = 50;
            if (nitroActive) {
                enginePower *= NITRO_MULTIPLIER;
            }
            
            const brakePower = 0.3;
            
            // Get current car's custom properties
            const currentCar = availableCars[currentCarIndex];
            let carAcceleration = currentCar.acceleration || 0.05;
            const carTopSpeed = currentCar.topSpeed || 1;
            
            // Calculate smooth nitro multiplier that fades out gradually
            let nitroMultiplier = 1.0;
            if (nitroActive) {
                nitroMultiplier = NITRO_MULTIPLIER; // Full nitro
            } else if (nitroFading) {
                // Smoothly interpolate from full nitro to no nitro
                nitroMultiplier = NITRO_MULTIPLIER * (1.0 - nitroFadeProgress);
            }
            
            // Apply nitro boost to acceleration
            carAcceleration *= nitroMultiplier;
            
            let acceleration = 0;
            let turnSpeed = 0.02;
            
            // Keyboard controls (only when not in free camera mode)
            if (!freeCameraMode) {
                if (keys['w'] || keys['arrowup']) {
                    acceleration = carAcceleration; // Use car's custom acceleration
                }
                if (keys['s'] || keys['arrowdown']) {
                    acceleration = -carAcceleration; // Use car's custom acceleration
                    currentSpeed *= 0.95;
                }
                
                if (keys['a'] || keys['arrowleft']) {
                    turnSpeed *= (1 + currentSpeed / 150);
                    carRotation += turnSpeed;
                }
                if (keys['d'] || keys['arrowright']) {
                    turnSpeed *= (1 + currentSpeed / 150);
                    carRotation -= turnSpeed;
                }
                
                if (keys[' '] && currentSpeed > 20) {
                    carRotation += (keys['a'] || keys['arrowleft'] ? 0.06 : keys['d'] || keys['arrowright'] ? -0.06 : 0);
                }
            }
            
            // Mobile controls (joystick)
            if (joystickActive) {
                // Forward/backward based on joystick Y
                if (joystickInput.y > 0.1) {
                    acceleration = carAcceleration * joystickInput.y; // Use car's custom acceleration
                } else if (joystickInput.y < -0.1) {
                    acceleration = carAcceleration * joystickInput.y; // Use car's custom acceleration
                    currentSpeed *= 0.95;
                }
                
                // Turning based on joystick X
                if (Math.abs(joystickInput.x) > 0.1) {
                    turnSpeed *= (1 + currentSpeed / 150);
                    carRotation -= turnSpeed * joystickInput.x;
                }
            }
            
            // Mobile nitro button
            if (mobileNitro && !nitroActive && nitroTimeLeft === 0 && !nitroFading) {
                nitroActive = true;
                nitroTimeLeft = NITRO_DURATION;
                nitroFading = false;
                nitroFadeProgress = 0;
            }
            
            // Mobile brake button
            if (mobileBrake) {
                currentSpeed *= 0.9;
                if (currentSpeed > 20) {
                    carRotation += joystickInput.x * 0.06;
                }
            }
            
            const forward = new THREE.Vector3(
                Math.sin(carRotation),
                0,
                Math.cos(carRotation)
            );
            
            carVelocity.add(forward.multiplyScalar(acceleration));
            carVelocity.multiplyScalar(0.985);
            
            // Apply speed limit based on car's top speed (increased scaling for higher speeds)
            let maxSpeed = carTopSpeed * 2.5; // Increased scaling factor for higher speeds
            
            // Apply smooth nitro boost to max speed
            maxSpeed *= nitroMultiplier;
            
            if (carVelocity.length() > maxSpeed) {
                carVelocity.normalize().multiplyScalar(maxSpeed);
            }
            
            currentSpeed = carVelocity.length() * 120; // Increased multiplier for speed display
            
            playerCar.position.add(carVelocity);
            playerCar.rotation.y = carRotation;
            
            // Jump physics for Batmobile Tumbler
            if (availableCars[currentCarIndex].name === 'Batmobile Tumbler') {
                if (isJumping) {
                    // Apply jump velocity to Y position
                    playerCar.position.y += jumpVelocity;
                    // Apply gravity
                    jumpVelocity -= GRAVITY;
                    
                    // Check if landed (back to or below ground level)
                    if (playerCar.position.y <= groundLevel) {
                        playerCar.position.y = groundLevel;
                        isJumping = false;
                        jumpVelocity = 0;
                        console.log('🦇 Batmobile Tumbler Landed!');
                    }
                } else {
                    // Store current ground level when not jumping
                    groundLevel = playerCar.position.y;
                }
            }
            
            if (playerCar.userData.wheels) {
                playerCar.userData.wheels.forEach(wheel => {
                    wheel.rotation.x -= currentSpeed * 0.08;
                });
            }
            
            // Update camera offsets - return to neutral when not dragging
            if (!isMouseDown) {
                targetOffsetX *= 0.95; // Gradually return to center
                targetOffsetY *= 0.95;
            }
            
            // Smooth interpolation of camera offsets
            cameraOffsetX = THREE.MathUtils.lerp(cameraOffsetX, targetOffsetX, 0.1);
            cameraOffsetY = THREE.MathUtils.lerp(cameraOffsetY, targetOffsetY, 0.1);
            
            // Calculate desired camera distance based on speed and car type
            const speedFactor = Math.min(currentSpeed / 100, 1);
            
            // Car-specific camera distances
            let minDistance = MIN_CAMERA_DISTANCE;
            let maxDistance = MAX_CAMERA_DISTANCE;
            
            if (availableCars[currentCarIndex].name === 'Batmobile Tumbler') {
                // Much further camera for Batmobile Tumbler
                minDistance = 30;  // 30 units away minimum
                maxDistance = 30;  // 30 units away maximum (constant distance)
            }
            
            const desiredDistance = minDistance + (maxDistance - minDistance) * speedFactor * 0.6;
            
            // Calculate camera position with car-specific positioning
            let targetCamPos;
            
            if (availableCars[currentCarIndex].name === 'Batmobile Tumbler') {
                // Shallower topological view for Batmobile Tumbler - 31 degree angle
                const topHeight = 300; // Camera height
                const behindDistance = 500; // Distance behind for ~31° angle
                
                targetCamPos = new THREE.Vector3(
                    playerCar.position.x - Math.sin(carRotation) * behindDistance,
                    playerCar.position.y + topHeight,
                    playerCar.position.z - Math.cos(carRotation) * behindDistance
                );
            } else {
                // Standard behind-car camera for other vehicles
                const baseAngle = carRotation + cameraOffsetX * 0.01; // Add horizontal offset
                const baseHeight = CAMERA_HEIGHT + cameraOffsetY * 0.01; // Add vertical offset
                
                targetCamPos = new THREE.Vector3(
                    playerCar.position.x - Math.sin(baseAngle) * desiredDistance,
                    playerCar.position.y + baseHeight,
                    playerCar.position.z - Math.cos(baseAngle) * desiredDistance
                );
            }
            
            // Handle camera positioning based on mode
            if (freeCameraMode) {
                // Free camera mode - use WASD for movement with full 3D flight
                const moveSpeed = 1.5;
                const camera_forward = new THREE.Vector3();
                const camera_right = new THREE.Vector3();
                const camera_up = new THREE.Vector3(0, 1, 0);
                
                // Get camera's forward and right vectors for relative movement
                camera.getWorldDirection(camera_forward);
                camera_right.crossVectors(camera_forward, camera_up).normalize();
                
                // WASD movement relative to camera orientation
                if (keys['w']) freeCameraPosition.add(camera_forward.clone().multiplyScalar(moveSpeed));
                if (keys['s']) freeCameraPosition.add(camera_forward.clone().multiplyScalar(-moveSpeed));
                if (keys['a']) freeCameraPosition.add(camera_right.clone().multiplyScalar(-moveSpeed));
                if (keys['d']) freeCameraPosition.add(camera_right.clone().multiplyScalar(moveSpeed));
                if (keys['q']) freeCameraPosition.y += moveSpeed; // Fly up
                if (keys['e']) freeCameraPosition.y -= moveSpeed; // Fly down
                
                camera.position.copy(freeCameraPosition);
                
                // Apply rotation to camera (mouse control handles rotation in onMouseMove)
                camera.rotation.copy(freeCameraRotation);
            } else {
                // Standard car-following camera
                // Smoothly interpolate camera position
                camera.position.lerp(targetCamPos, 0.15);
                
                // Ensure camera doesn't get too far from the car (using car-specific max distance)
                const actualDistance = camera.position.distanceTo(playerCar.position);
                if (actualDistance > maxDistance) {
                    const direction = new THREE.Vector3().subVectors(camera.position, playerCar.position).normalize();
                    camera.position.copy(playerCar.position).add(direction.multiplyScalar(maxDistance));
                }
                
                // Look directly at the car (pointing down towards it)
                camera.lookAt(playerCar.position.x, playerCar.position.y, playerCar.position.z);
            }
            
            // Update UI displays
            document.getElementById('speedValue').textContent = Math.round(currentSpeed);
            updateNitroDisplay();
        }
        
        function updateNitroDisplay() {
            const nitroFill = document.getElementById('nitroFill');
            const nitroDisplay = document.getElementById('nitroDisplay');
            
            if (nitroActive) {
                const percentage = (nitroTimeLeft / NITRO_DURATION) * 100;
                nitroFill.style.width = percentage + '%';
                nitroDisplay.classList.add('nitro-active');
            } else if (nitroFading) {
                // Show fading progress
                const fadePercentage = (1.0 - nitroFadeProgress) * 100;
                nitroFill.style.width = fadePercentage + '%';
                nitroDisplay.classList.add('nitro-active');
            } else {
                nitroFill.style.width = '100%';
                nitroDisplay.classList.remove('nitro-active');
            }
        }

        function onKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            // Debug all key presses with extra detail
            console.log('🔍 Key pressed:', e.key, 'Code:', e.code, 'Target:', e.target.tagName, 'Active element:', document.activeElement.tagName);
            
            // Developer menu toggle with 0 key - prevent default and stop propagation
            if (e.key === '0') {
                e.preventDefault();
                e.stopPropagation();
                console.log('🛠️ 0 key detected - preventing default and toggling menu');
                toggleDeveloperMenu();
                return;
            }
            
            // Car switching with T key (cycles through all cars)
            if (e.key.toLowerCase() === 't') {
                switchCar();
            }
            
            // Direct car selection with number keys 1-6
            if (e.key >= '1' && e.key <= '6') {
                const targetIndex = parseInt(e.key) - 1;
                if (targetIndex < availableCars.length) {
                    switchToSpecificCar(targetIndex);
                }
            }
            
            // Nitro activation - only Shift keys (removed N key)
            if ((e.key === 'Shift' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !nitroActive && nitroTimeLeft === 0 && !nitroFading) {
                console.log('🚀 NITRO ACTIVATED! Key:', e.key, 'Code:', e.code);
                nitroActive = true;
                nitroTimeLeft = NITRO_DURATION;
                nitroFading = false;
                nitroFadeProgress = 0;
            }
            
            // Jump activation for Batmobile Tumbler (E key)
            if (e.key.toLowerCase() === 'e' && availableCars[currentCarIndex].name === 'Batmobile Tumbler') {
                if (!isJumping) {
                    isJumping = true;
                    jumpVelocity = JUMP_POWER;
                    console.log('🦇 Batmobile Tumbler Jump!');
                }
            }
        }
        
        function switchCar() {
            // Store current car position and rotation
            const currentPosition = playerCar ? playerCar.position.clone() : new THREE.Vector3(0, 0, 0);
            const currentRotation = carRotation;
            const currentVelocity = carVelocity.clone();
            const currentSpeedValue = currentSpeed;
            
            // Switch to next car
            currentCarIndex = (currentCarIndex + 1) % availableCars.length;
            
            // Create new car
            createPlayerCar();
            
            // Wait a moment for the car to load, then restore position
            setTimeout(() => {
                if (playerCar) {
                    playerCar.position.copy(currentPosition);
                    carRotation = currentRotation;
                    carVelocity.copy(currentVelocity);
                    currentSpeed = currentSpeedValue;
                    playerCar.rotation.y = carRotation;
                    
                    console.log(`Switched to: ${availableCars[currentCarIndex].name}`);
                    updateCarDisplay();
                }
            }, 100);
        }
        
        function switchToSpecificCar(targetIndex) {
            // Don't switch if already using this car
            if (currentCarIndex === targetIndex) {
                console.log(`Already using: ${availableCars[currentCarIndex].name}`);
                return;
            }
            
            // Store current car position and rotation
            const currentPosition = playerCar ? playerCar.position.clone() : new THREE.Vector3(0, 0, 0);
            const currentRotation = carRotation;
            const currentVelocity = carVelocity.clone();
            const currentSpeedValue = currentSpeed;
            
            // Switch to specific car
            currentCarIndex = targetIndex;
            
            // Create new car
            createPlayerCar();
            
            // Wait a moment for the car to load, then restore position
            setTimeout(() => {
                if (playerCar) {
                    playerCar.position.copy(currentPosition);
                    carRotation = currentRotation;
                    carVelocity.copy(currentVelocity);
                    currentSpeed = currentSpeedValue;
                    playerCar.rotation.y = carRotation;
                    
                    console.log(`Switched to: ${availableCars[currentCarIndex].name} (Key ${targetIndex + 1})`);
                    updateCarDisplay();
                }
            }, 100);
        }
        
        function updateCarDisplay() {
            document.getElementById('carName').textContent = availableCars[currentCarIndex].name;
            
            // Update car guide highlighting
            const carListItems = document.querySelectorAll('#carGuide .car-list li');
            carListItems.forEach((item, index) => {
                if (index === currentCarIndex) {
                    item.style.backgroundColor = 'rgba(255, 102, 0, 0.3)';
                    item.style.borderLeft = '3px solid #ff6600';
                    item.style.paddingLeft = '8px';
                } else {
                    item.style.backgroundColor = 'transparent';
                    item.style.borderLeft = 'none';
                    item.style.paddingLeft = '2px';
                }
            });
        }
        
        function activateNitro() {
            if (!nitroActive && nitroTimeLeft === 0 && !nitroFading) {
                nitroActive = true;
                nitroTimeLeft = NITRO_DURATION;
                nitroFading = false;
                nitroFadeProgress = 0;
            }
        }

        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }
        
        function onMouseDown(e) {
            isMouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }
        
        function onMouseMove(e) {
            if (isMouseDown) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                if (freeCameraMode) {
                    // Free camera mouse look controls
                    const mouseSensitivity = 0.003;
                    freeCameraRotation.y -= deltaX * mouseSensitivity;
                    freeCameraRotation.x -= deltaY * mouseSensitivity;
                    
                    // Constrain vertical rotation to prevent flipping
                    freeCameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, freeCameraRotation.x));
                    
                    // Update mouse position for next frame
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                } else {
                    // Standard camera offset controls for follow mode
                    // Update target offsets based on mouse movement (fix reversed controls)
                    targetOffsetX = Math.max(-200, Math.min(200, -deltaX)); // Reverse horizontal
                    targetOffsetY = Math.max(-100, Math.min(100, deltaY)); // Don't invert Y
                }
            }
        }
        
        function onMouseUp(e) {
            isMouseDown = false;
            // Target offsets will gradually return to 0 in updateCarPhysics
        }
        
        function initMobileControls() {
            const joystick = document.getElementById('joystick');
            const joystickHandle = document.getElementById('joystickHandle');
            const nitroBtn = document.getElementById('nitroBtn');
            const brakeBtn = document.getElementById('brakeBtn');
            const switchCarBtn = document.getElementById('switchCarBtn');
            
            // Get joystick center position
            const joystickRect = joystick.getBoundingClientRect();
            joystickCenter.x = joystickRect.left + joystickRect.width / 2;
            joystickCenter.y = joystickRect.top + joystickRect.height / 2;
            
            // Joystick touch events
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                handleJoystickMove(e.touches[0]);
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickActive) {
                    handleJoystickMove(e.touches[0]);
                }
            });
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickInput.x = 0;
                joystickInput.y = 0;
                joystickHandle.style.transform = 'translate(-50%, -50%)';
            });
            
            // Button events
            nitroBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mobileNitro = true;
                activateNitro();
            });
            
            nitroBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileNitro = false;
            });
            
            brakeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mobileBrake = true;
            });
            
            brakeBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileBrake = false;
            });
            
            // Switch car button events
            switchCarBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                switchCar();
            });
            
            // Update joystick center on window resize
            window.addEventListener('resize', () => {
                const rect = joystick.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
            });
        }
        
        function handleJoystickMove(touch) {
            const deltaX = touch.clientX - joystickCenter.x;
            const deltaY = touch.clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 40; // Half of joystick radius
            
            if (distance <= maxDistance) {
                joystickInput.x = deltaX / maxDistance;
                joystickInput.y = -deltaY / maxDistance; // Invert Y for forward/backward
                
                document.getElementById('joystickHandle').style.transform = 
                    `translate(${-50 + (deltaX / maxDistance) * 50}%, ${-50 + (deltaY / maxDistance) * 50}%)`;
            } else {
                const angle = Math.atan2(deltaY, deltaX);
                const constrainedX = Math.cos(angle) * maxDistance;
                const constrainedY = Math.sin(angle) * maxDistance;
                
                joystickInput.x = constrainedX / maxDistance;
                joystickInput.y = -constrainedY / maxDistance;
                
                document.getElementById('joystickHandle').style.transform = 
                    `translate(${-50 + (constrainedX / maxDistance) * 50}%, ${-50 + (constrainedY / maxDistance) * 50}%)`;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCarPhysics();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Developer Menu Functions
        let developerMenuOpen = false;
        let freeCameraMode = false;
        let freeCameraPosition = new THREE.Vector3();
        let freeCameraRotation = new THREE.Euler();
        
        function toggleDeveloperMenu() {
            console.log('🛠️ toggleDeveloperMenu called, current state:', developerMenuOpen);
            const menu = document.getElementById('developerMenu');
            console.log('🛠️ Menu element found:', !!menu);
            
            if (!menu) {
                console.error('❌ Developer menu element not found!');
                return;
            }
            
            developerMenuOpen = !developerMenuOpen;
            
            if (developerMenuOpen) {
                menu.style.display = 'block';
                menu.style.visibility = 'visible';
                menu.style.opacity = '1';
                menu.style.zIndex = '9999';
                console.log('🛠️ Menu OPENED - display:', menu.style.display);
                initializeDeveloperMenu();
            } else {
                menu.style.display = 'none';
                menu.style.visibility = 'hidden';
                menu.style.opacity = '0';
                console.log('🛠️ Menu CLOSED - display:', menu.style.display);
            }
            
            console.log('🛠️ Final menu state - developerMenuOpen:', developerMenuOpen, 'computed style:', window.getComputedStyle(menu).display);
        }
        
        function initializeDeveloperMenu() {
            const carSettings = document.getElementById('carSettings');
            carSettings.innerHTML = '';
            
            // Create controls for each vehicle
            availableCars.forEach((car, index) => {
                const carDiv = document.createElement('div');
                carDiv.className = 'setting-group';
                carDiv.innerHTML = `
                    <h4 style="color: #00ff00; margin: 10px 0 5px 0;">${car.name}</h4>
                    <label>Top Speed:</label>
                    <input type="range" id="topSpeed${index}" min="0.1" max="2" step="0.1" value="${car.topSpeed || 1}">
                    <input type="number" id="topSpeedValue${index}" value="${car.topSpeed || 1}" step="0.1">
                    <label>Acceleration:</label>
                    <input type="range" id="acceleration${index}" min="0.01" max="0.1" step="0.01" value="${car.acceleration || 0.05}">
                    <input type="number" id="accelerationValue${index}" value="${car.acceleration || 0.05}" step="0.01">
                `;
                carSettings.appendChild(carDiv);
                
                // Add event listeners
                const topSpeedRange = document.getElementById(`topSpeed${index}`);
                const topSpeedValue = document.getElementById(`topSpeedValue${index}`);
                const accelerationRange = document.getElementById(`acceleration${index}`);
                const accelerationValue = document.getElementById(`accelerationValue${index}`);
                
                topSpeedRange.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    topSpeedValue.value = value;
                    car.topSpeed = value;
                });
                
                topSpeedValue.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    topSpeedRange.value = value;
                    car.topSpeed = value;
                });
                
                accelerationRange.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    accelerationValue.value = value;
                    car.acceleration = value;
                });
                
                accelerationValue.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    accelerationRange.value = value;
                    car.acceleration = value;
                });
            });
            
            // Camera toggle
            const cameraToggle = document.getElementById('cameraToggle');
            const cameraMode = document.getElementById('cameraMode');
            cameraToggle.addEventListener('change', (e) => {
                freeCameraMode = e.target.checked;
                cameraMode.textContent = freeCameraMode ? 'Free Camera' : 'Follow Car';
                
                if (freeCameraMode) {
                    // Store current camera position and rotation
                    freeCameraPosition.copy(camera.position);
                    freeCameraRotation.copy(camera.rotation);
                } else {
                    // Reset to follow mode - camera will automatically position behind car
                    camera.rotation.set(0, 0, 0);
                }
            });
            
            // Camera distance and height
            setupRangeSync('cameraDistance', 'cameraDistanceValue');
            setupRangeSync('cameraHeight', 'cameraHeightValue');
            setupRangeSync('jumpPower', 'jumpPowerValue', (value) => {
                window.JUMP_POWER = value;
            });
            setupRangeSync('gravity', 'gravityValue', (value) => {
                window.GRAVITY = value;
            });
            setupRangeSync('mapScale', 'mapScaleValue', (value) => {
                mapScale = value;
                updateMapScale();
            });
            
            // Map upload functionality
            const mapUpload = document.getElementById('mapUpload');
            mapUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    console.log('📁 Map file selected:', file.name);
                    
                    // Check file type
                    const validTypes = ['.gltf', '.glb'];
                    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
                    
                    if (!validTypes.includes(fileExtension)) {
                        alert('Please select a valid GLTF (.gltf) or GLB (.glb) file.');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const arrayBuffer = event.target.result;
                        console.log('📖 File read successfully, size:', arrayBuffer.byteLength, 'bytes');
                        createTrack('custom', arrayBuffer);
                    };
                    
                    reader.onerror = (error) => {
                        console.error('❌ Error reading file:', error);
                        alert('Error reading the selected file.');
                    };
                    
                    // Read as ArrayBuffer for GLB files or text for GLTF
                    if (fileExtension === '.glb') {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsArrayBuffer(file); // GLTF loader can handle both
                    }
                }
            });
            
            // Texture upload functionality
            const carTextureUpload = document.getElementById('carTextureUpload');
            carTextureUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    console.log('🎨 Car texture file selected:', file.name);
                    
                    // Check file type
                    const validTypes = ['.jpg', '.jpeg', '.png'];
                    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
                    
                    if (!validTypes.includes(fileExtension)) {
                        alert('Please select a valid image file (.jpg, .jpeg, .png).');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const imageSrc = event.target.result;
                        
                        // Load texture using Three.js
                        textureLoader.load(imageSrc, (texture) => {
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            cachedCarTexture = texture;
                            console.log('✅ Car texture loaded and cached successfully');
                            alert('Car texture loaded! Use "Apply Texture to Current Car" to apply it.');
                        }, undefined, (error) => {
                            console.error('❌ Error loading car texture:', error);
                            alert('Error loading car texture.');
                        });
                    };
                    
                    reader.onerror = (error) => {
                        console.error('❌ Error reading texture file:', error);
                        alert('Error reading the selected texture file.');
                    };
                    
                    reader.readAsDataURL(file);
                }
            });
            
            const envTextureUpload = document.getElementById('envTextureUpload');
            envTextureUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    console.log('🌍 Environment texture file selected:', file.name);
                    
                    // Check file type
                    const validTypes = ['.jpg', '.jpeg', '.png'];
                    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
                    
                    if (!validTypes.includes(fileExtension)) {
                        alert('Please select a valid image file (.jpg, .jpeg, .png).');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const imageSrc = event.target.result;
                        
                        // Load texture using Three.js
                        textureLoader.load(imageSrc, (texture) => {
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            cachedEnvTexture = texture;
                            console.log('✅ Environment texture loaded and cached successfully');
                            alert('Environment texture loaded! Use "Apply Environment Texture" to apply it.');
                        }, undefined, (error) => {
                            console.error('❌ Error loading environment texture:', error);
                            alert('Error loading environment texture.');
                        });
                    };
                    
                    reader.onerror = (error) => {
                        console.error('❌ Error reading texture file:', error);
                        alert('Error reading the selected texture file.');
                    };
                    
                    reader.readAsDataURL(file);
                }
            });
        }
        
        function setupRangeSync(rangeId, valueId, callback) {
            const range = document.getElementById(rangeId);
            const value = document.getElementById(valueId);
            
            range.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                value.value = val;
                if (callback) callback(val);
            });
            
            value.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                range.value = val;
                if (callback) callback(val);
            });
        }
        
        function resetToDefaults() {
            // Reset car properties to the high-performance defaults
            availableCars[0].topSpeed = 1.0; availableCars[0].acceleration = 0.045; // MB Car ~300 km/h
            availableCars[1].topSpeed = 1.2; availableCars[1].acceleration = 0.055; // GT3 Porsche ~360 km/h
            availableCars[2].topSpeed = 1.4; availableCars[2].acceleration = 0.065; // Batmobile Tumbler ~420 km/h
            availableCars[3].topSpeed = 1.1; availableCars[3].acceleration = 0.050; // Batmobile 1989 ~330 km/h
            availableCars[4].topSpeed = 1.3; availableCars[4].acceleration = 0.060; // Lamborghini Diablo ~390 km/h
            availableCars[5].topSpeed = 1.15; availableCars[5].acceleration = 0.065; // Dodge Hellcat ~345 km/h
            
            // Reset world settings
            window.JUMP_POWER = 10;
            window.GRAVITY = 0.8;
            
            // Reset camera
            freeCameraMode = false;
            document.getElementById('cameraToggle').checked = false;
            document.getElementById('cameraMode').textContent = 'Follow Car';
            
            // Reinitialize menu
            if (developerMenuOpen) {
                initializeDeveloperMenu();
            }
            
            console.log('🔄 All settings reset to high-performance defaults');
        }
        
        function saveSettings() {
            const settings = {
                cars: availableCars.map(car => ({
                    name: car.name,
                    topSpeed: car.topSpeed || 1,
                    acceleration: car.acceleration || 0.05
                })),
                jumpPower: window.JUMP_POWER || 10,
                gravity: window.GRAVITY || 0.8,
                camera: {
                    distance: document.getElementById('cameraDistance').value,
                    height: document.getElementById('cameraHeight').value
                }
            };
            
            localStorage.setItem('carGameSettings', JSON.stringify(settings));
            console.log('💾 Settings saved to localStorage');
        }
        
        function loadSettings() {
            const saved = localStorage.getItem('carGameSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                
                // Apply car settings
                settings.cars.forEach((savedCar, index) => {
                    if (availableCars[index]) {
                        availableCars[index].topSpeed = savedCar.topSpeed;
                        availableCars[index].acceleration = savedCar.acceleration;
                    }
                });
                
                // Apply world settings
                window.JUMP_POWER = settings.jumpPower;
                window.GRAVITY = settings.gravity;
                
                // Reinitialize menu
                if (developerMenuOpen) {
                    initializeDeveloperMenu();
                }
                
                console.log('📁 Settings loaded from localStorage');
            } else {
                console.log('❌ No saved settings found');
            }
        }

        // Texture Management Functions
        function applyCachedTexture() {
            if (!cachedCarTexture) {
                alert('No car texture loaded. Please upload a texture first.');
                return;
            }
            
            if (!playerCar) {
                alert('No car is currently loaded.');
                return;
            }
            
            // Store original materials before applying texture
            playerCar.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (!originalCarMaterials.has(child.uuid)) {
                        originalCarMaterials.set(child.uuid, child.material.clone());
                    }
                    
                    // Apply the texture
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => {
                            mat.map = cachedCarTexture;
                            mat.needsUpdate = true;
                        });
                    } else {
                        child.material.map = cachedCarTexture;
                        child.material.needsUpdate = true;
                    }
                }
            });
            
            console.log('🎨 Car texture applied successfully');
        }
        
        function resetCarTexture() {
            if (!playerCar) {
                alert('No car is currently loaded.');
                return;
            }
            
            // Restore original materials
            playerCar.traverse((child) => {
                if (child.isMesh && child.material) {
                    const originalMaterial = originalCarMaterials.get(child.uuid);
                    if (originalMaterial) {
                        child.material = originalMaterial.clone();
                    }
                }
            });
            
            console.log('🔄 Car texture reset to original');
        }
        
        function applyCachedEnvTexture() {
            if (!cachedEnvTexture) {
                alert('No environment texture loaded. Please upload a texture first.');
                return;
            }
            
            if (!currentMap) {
                alert('No map is currently loaded.');
                return;
            }
            
            // Apply texture to map elements
            currentMap.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => {
                            mat.map = cachedEnvTexture;
                            mat.needsUpdate = true;
                        });
                    } else {
                        child.material.map = cachedEnvTexture;
                        child.material.needsUpdate = true;
                    }
                }
            });
            
            console.log('🌍 Environment texture applied successfully');
        }
        
        function resetEnvTexture() {
            if (!currentMap) {
                alert('No map is currently loaded.');
                return;
            }
            
            // Reload the default map to reset textures
            loadDefaultMap();
            console.log('🔄 Environment texture reset to original');
        }

        init();
    </script>
</body>
</html>
    </script>
</body>
</html>
